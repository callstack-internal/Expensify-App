diff --git a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
index fad559d..2a6b4a6 100644
--- a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
+++ b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
@@ -280,7 +280,7 @@ class VirtualizedList extends StateSafePureComponent {
   // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
 
   constructor(_props) {
-    var _this$props$updateCel;
+    var _this$props$updateCel, _this$props$maintainV, _this$props$maintainV2;
     super(_props);
     this._getScrollMetrics = () => {
       return this._scrollMetrics;
@@ -515,6 +515,11 @@ class VirtualizedList extends StateSafePureComponent {
         visibleLength,
         zoomScale
       };
+      if (this.state.pendingScrollUpdateCount > 0) {
+        this.setState(state => ({
+          pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1
+        }));
+      }
       this._updateViewableItems(this.props, this.state.cellsAroundViewport);
       if (!this.props) {
         return;
@@ -564,7 +569,7 @@ class VirtualizedList extends StateSafePureComponent {
     this._updateCellsToRender = () => {
       this._updateViewableItems(this.props, this.state.cellsAroundViewport);
       this.setState((state, props) => {
-        var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport);
+        var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);
         var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));
         if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
           return null;
@@ -584,7 +589,7 @@ class VirtualizedList extends StateSafePureComponent {
       return {
         index,
         item,
-        key: this._keyExtractor(item, index, props),
+        key: VirtualizedList._keyExtractor(item, index, props),
         isViewable
       };
     };
@@ -616,12 +621,10 @@ class VirtualizedList extends StateSafePureComponent {
     };
     this._getFrameMetrics = (index, props) => {
       var data = props.data,
-        getItem = props.getItem,
         getItemCount = props.getItemCount,
         getItemLayout = props.getItemLayout;
       invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
-      var item = getItem(data, index);
-      var frame = this._frames[this._keyExtractor(item, index, props)];
+      var frame = this._frames[VirtualizedList._getItemKey(props, index)];
       if (!frame || frame.index !== index) {
         if (getItemLayout) {
           /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
@@ -645,7 +648,7 @@ class VirtualizedList extends StateSafePureComponent {
 
       // The last cell we rendered may be at a new index. Bail if we don't know
       // where it is.
-      if (focusedCellIndex >= itemCount || this._keyExtractor(props.getItem(props.data, focusedCellIndex), focusedCellIndex, props) !== this._lastFocusedCellKey) {
+      if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== this._lastFocusedCellKey) {
         return [];
       }
       var first = focusedCellIndex;
@@ -685,9 +688,15 @@ class VirtualizedList extends StateSafePureComponent {
       }
     }
     var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
+    var minIndexForVisible = (_this$props$maintainV = (_this$props$maintainV2 = this.props.maintainVisibleContentPosition) == null ? void 0 : _this$props$maintainV2.minIndexForVisible) !== null && _this$props$maintainV !== void 0 ? _this$props$maintainV : 0;
     this.state = {
       cellsAroundViewport: initialRenderRegion,
-      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)
+      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion),
+      firstVisibleItemKey: this.props.getItemCount(this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,
+      // When we have a non-zero initialScrollIndex, we will receive a
+      // scroll event later so this will prevent the window from updating
+      // until we get a valid offset.
+      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0
     };
 
     // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
@@ -743,6 +752,27 @@ class VirtualizedList extends StateSafePureComponent {
       }
     }
   }
+  static _findItemIndexWithKey(props, key, hint) {
+      var itemCount = props.getItemCount(props.data);
+      if (hint != null && hint >= 0 && hint < itemCount) {
+      var curKey = VirtualizedList._getItemKey(props, hint);
+      if (curKey === key) {
+        return hint;
+      }
+    }
+    for (var ii = 0; ii < itemCount; ii++) {
+        var _curKey = VirtualizedList._getItemKey(props, ii);
+        if (_curKey === key) {
+          return ii;
+        }
+      }
+    return null;
+  }
+    static _getItemKey(props, index) {
+    var item = props.getItem(props.data, index);
+      return VirtualizedList._keyExtractor(item, index, props);
+  }
+
   static _createRenderMask(props, cellsAroundViewport, additionalRegions) {
     var itemCount = props.getItemCount(props.data);
     invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, "Invalid cells around viewport \"[" + cellsAroundViewport.first + ", " + cellsAroundViewport.last + "]\" was passed to VirtualizedList._createRenderMask");
@@ -791,7 +821,7 @@ class VirtualizedList extends StateSafePureComponent {
       }
     }
   }
-  _adjustCellsAroundViewport(props, cellsAroundViewport) {
+  _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {
     var data = props.data,
       getItemCount = props.getItemCount;
     var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
@@ -814,17 +844,10 @@ class VirtualizedList extends StateSafePureComponent {
         last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
       };
     } else {
-      // If we have a non-zero initialScrollIndex and run this before we've scrolled,
-      // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
-      // So let's wait until we've scrolled the view to the right place. And until then,
-      // we will trust the initialScrollIndex suggestion.
       
-      // Thus, we want to recalculate the windowed render limits if any of the following hold:
-      // - initialScrollIndex is undefined or is 0
-      // - initialScrollIndex > 0 AND scrolling is complete
-      // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
-      //   where the list is shorter than the visible area)
-      if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {
+      // If we have a pending scroll update, we should not adjust the render window as it
+      // might override the correct window.
+    if (pendingScrollUpdateCount > 0) {
         return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
       }
       newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
@@ -897,16 +920,36 @@ class VirtualizedList extends StateSafePureComponent {
     }
   }
   static getDerivedStateFromProps(newProps, prevState) {
+    var _newProps$maintainVis, _newProps$maintainVis2;
     // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
     // sure we're rendering a reasonable range here.
     var itemCount = newProps.getItemCount(newProps.data);
     if (itemCount === prevState.renderMask.numCells()) {
       return prevState;
     }
-    var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);
+    var maintainVisibleContentPositionAdjustment = null;
+    var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
+    var minIndexForVisible = (_newProps$maintainVis = (_newProps$maintainVis2 = newProps.maintainVisibleContentPosition) == null ? void 0 : _newProps$maintainVis2.minIndexForVisible) !== null && _newProps$maintainVis !== void 0 ? _newProps$maintainVis : 0;
+    var newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
+    if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
+      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
+      // Fast path if items were added at the start of the list.
+      var hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;
+      var firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);
+      maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;
+      } else {
+        maintainVisibleContentPositionAdjustment = null;
+      }
+    }
+    var constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {
+        first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,
+        last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment
+    } : prevState.cellsAroundViewport, newProps);
     return {
       cellsAroundViewport: constrainedCells,
-      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)
+      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
+      firstVisibleItemKey: newFirstVisibleItemKey,
+      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCoun
     };
   }
   _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
@@ -929,7 +972,7 @@ class VirtualizedList extends StateSafePureComponent {
     last = Math.min(end, last);
     var _loop = function _loop() {
       var item = getItem(data, ii);
-      var key = _this._keyExtractor(item, ii, _this.props);
+      var key = VirtualizedList._keyExtractor(item, ii, _this.props);
       _this._indicesToKeys.set(ii, key);
       if (stickyIndicesFromProps.has(ii + stickyOffset)) {
         stickyHeaderIndices.push(cells.length);
@@ -964,20 +1007,23 @@ class VirtualizedList extends StateSafePureComponent {
   }
   static _constrainToItemCount(cells, props) {
     var itemCount = props.getItemCount(props.data);
-    var last = Math.min(itemCount - 1, cells.last);
+    var lastPossibleCellIndex = itemCount - 1;
+    
+    // Constraining `last` may significantly shrink the window. Adjust `first`
+    // to expand the window if the new `last` results in a new window smaller
+    // than the number of cells rendered per batch.
     var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
+    var maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);
     return {
-      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
-      last
+      first: clamp(0, cells.first, maxFirst),
+      last: Math.min(lastPossibleCellIndex, cells.last)
     };
   }
   _isNestedWithSameOrientation() {
     var nestedContext = this.context;
     return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
   }
-  _keyExtractor(item, index, props
-  // $FlowFixMe[missing-local-annot]
-  ) {
+  static _keyExtractor(item, index, props) {
     if (props.keyExtractor != null) {
       return props.keyExtractor(item, index);
     }
@@ -1018,6 +1064,10 @@ class VirtualizedList extends StateSafePureComponent {
         cellKey: this._getCellKey() + '-header',
         key: "$header"
       }, /*#__PURE__*/React.createElement(View, {
+        // We expect that header component will be a single native view so make it
+        // not collapsable to avoid this view being flattened and make this assumption
+        // no longer true.
+        collapsable: false,
         onLayout: this._onLayoutHeader,
         style: [inversionStyle, this.props.ListHeaderComponentStyle]
       },
@@ -1120,7 +1170,11 @@ class VirtualizedList extends StateSafePureComponent {
       // TODO: Android support
       invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
       stickyHeaderIndices,
-      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
+      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,
+      maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? _objectSpread(_objectSpread({}, this.props.maintainVisibleContentPosition), {}, {
+        // Adjust index to account for ListHeaderComponent.
+        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)
+      }) : undefined
     });
     this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
     var innerRet = /*#__PURE__*/React.createElement(VirtualizedListContextProvider, {
@@ -1313,8 +1367,12 @@ class VirtualizedList extends StateSafePureComponent {
       onStartReached = _this$props8.onStartReached,
       onStartReachedThreshold = _this$props8.onStartReachedThreshold,
       onEndReached = _this$props8.onEndReached,
-      onEndReachedThreshold = _this$props8.onEndReachedThreshold,
-      initialScrollIndex = _this$props8.initialScrollIndex;
+      onEndReachedThreshold = _this$props8.onEndReachedThreshold;
+      // If we have any pending scroll updates it means that the scroll metrics
+      // are out of date and we should not call any of the edge reached callbacks.
+      if (this.state.pendingScrollUpdateCount > 0) {
+          return;
+      }
     var _this$_scrollMetrics2 = this._scrollMetrics,
       contentLength = _this$_scrollMetrics2.contentLength,
       visibleLength = _this$_scrollMetrics2.visibleLength,
@@ -1354,16 +1412,10 @@ class VirtualizedList extends StateSafePureComponent {
     // and call onStartReached only once for a given content length,
     // and only if onEndReached is not being executed
     else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
-      // On initial mount when using initialScrollIndex the offset will be 0 initially
-      // and will trigger an unexpected onStartReached. To avoid this we can use
-      // timestamp to differentiate between the initial scroll metrics and when we actually
-      // received the first scroll event.
-      if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
-        this._sentStartForContentLength = this._scrollMetrics.contentLength;
-        onStartReached({
-          distanceFromStart
-        });
-      }
+          this._sentStartForContentLength = this._scrollMetrics.contentLength;
+          onStartReached({
+            distanceFromStart
+          });
     }
 
     // If the user scrolls away from the start or end and back again,
@@ -1429,6 +1481,11 @@ class VirtualizedList extends StateSafePureComponent {
    */
 
   _updateViewableItems(props, cellsAroundViewport) {
+    // If we have any pending scroll updates it means that the scroll metrics
+    // are out of date and we should not call any of the visibility callbacks.
+    if (this.state.pendingScrollUpdateCount > 0) {
+      return;
+    }
     this._viewabilityTuples.forEach(tuple => {
       tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
     });
