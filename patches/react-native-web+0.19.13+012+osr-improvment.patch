diff --git a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
index fe095a7..a7ed153 100644
--- a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
+++ b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
@@ -335,7 +335,7 @@ class VirtualizedList extends StateSafePureComponent {
       zoomScale: 1
     };
     this._scrollRef = null;
-    this._sentStartForContentLength = 0;
+    this._sentStartForFirstVisibleItemKey = null;
     this._sentEndForContentLength = 0;
     this._totalCellLength = 0;
     this._totalCellsMeasured = 0;
@@ -687,16 +687,19 @@ class VirtualizedList extends StateSafePureComponent {
         });
       }
     }
+    var itemCount = this.props.getItemCount(this.props.data);
     var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
     var minIndexForVisible = (_this$props$maintainV = (_this$props$maintainV2 = this.props.maintainVisibleContentPosition) == null ? void 0 : _this$props$maintainV2.minIndexForVisible) !== null && _this$props$maintainV !== void 0 ? _this$props$maintainV : 0;
+    var itemCount = this.props.getItemCount(this.props.data);
     this.state = {
       cellsAroundViewport: initialRenderRegion,
       renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion),
-      firstVisibleItemKey: this.props.getItemCount(this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,
+      firstVisibleItemKey: itemCount > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,
       // When we have a non-zero initialScrollIndex, we will receive a
       // scroll event later so this will prevent the window from updating
       // until we get a valid offset.
-      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0
+      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0,
+      lastItemCount: itemCount
     };
 
     // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
@@ -924,13 +927,13 @@ class VirtualizedList extends StateSafePureComponent {
     // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
     // sure we're rendering a reasonable range here.
     var itemCount = newProps.getItemCount(newProps.data);
-    if (itemCount === prevState.renderMask.numCells()) {
+    if (itemCount === prevState.renderMask.numCells() && itemCount === prevState.lastItemCount) {
       return prevState;
     }
     var maintainVisibleContentPositionAdjustment = null;
     var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
     var minIndexForVisible = (_newProps$maintainVis = (_newProps$maintainVis2 = newProps.maintainVisibleContentPosition) == null ? void 0 : _newProps$maintainVis2.minIndexForVisible) !== null && _newProps$maintainVis !== void 0 ? _newProps$maintainVis : 0;
-    var newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
+    var newFirstVisibleItemKey = itemCount > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
     if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
       if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
       // Fast path if items were added at the start of the list.
@@ -949,7 +952,8 @@ class VirtualizedList extends StateSafePureComponent {
       cellsAroundViewport: constrainedCells,
       renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
       firstVisibleItemKey: newFirstVisibleItemKey,
-      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCoun
+      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount,
+      lastItemCount: itemCount
     };
   }
   _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
@@ -1224,7 +1228,7 @@ class VirtualizedList extends StateSafePureComponent {
       return ret;
     }
   }
-  componentDidUpdate(prevProps) {
+  componentDidUpdate(prevProps, prevState) {
     var _this$props7 = this.props,
       data = _this$props7.data,
       extraData = _this$props7.extraData;
@@ -1248,6 +1252,11 @@ class VirtualizedList extends StateSafePureComponent {
     if (hiPriInProgress) {
       this._hiPriInProgress = false;
     }
+
+    if (this.state.cellsAroundViewport.first !== prevState.cellsAroundViewport.first ||
+        this.state.cellsAroundViewport.last !== prevState.cellsAroundViewport.last) {
+      this._maybeCallOnEdgeReached();
+    }
   }
 
   // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex
@@ -1411,8 +1420,8 @@ class VirtualizedList extends StateSafePureComponent {
     // Next check if the user just scrolled within the start threshold
     // and call onStartReached only once for a given content length,
     // and only if onEndReached is not being executed
-    else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
-          this._sentStartForContentLength = this._scrollMetrics.contentLength;
+    else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this.state.firstVisibleItemKey !== this._sentStartForFirstVisibleItemKey) {
+          this._sentStartForFirstVisibleItemKey = this.state.firstVisibleItemKey;
           onStartReached({
             distanceFromStart
           });
@@ -1421,7 +1430,7 @@ class VirtualizedList extends StateSafePureComponent {
     // If the user scrolls away from the start or end and back again,
     // cause onStartReached or onEndReached to be triggered again
     else {
-      this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
+      this._sentStartForFirstVisibleItemKey = isWithinStartThreshold ? this._sentStartForFirstVisibleItemKey : null;
       this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
     }
   }
